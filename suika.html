<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フルーツ進化ゲーム</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #87CEEB;
            color: white;
            text-align: center;
            margin: 0;
            padding: 0;
        }
        canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid white;
            background-color: #001F3F;
        }
        #score {
            font-size: 24px;
        }
        #gameOver {
            font-size: 36px;
            color: red;
            display: none;
        }
    </style>
</head>
<body>
    <h1>フルーツ進化ゲーム</h1>
    <div id="score">スコア: <span id="scoreValue">0</span></div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div id="gameOver">ゲームオーバー</div>
    <script>
        const { Engine, Render, World, Bodies, Body, Events } = Matter;

        const engine = Engine.create();
        const render = Render.create({
            element: document.body,
            canvas: document.getElementById("gameCanvas"),
            engine: engine,
            options: {
                width: 400,
                height: 600,
                wireframes: false
            }
        });

        const ground = Bodies.rectangle(200, 590, 400, 20, { isStatic: true });
        const leftWall = Bodies.rectangle(0, 300, 20, 600, { isStatic: true });
        const rightWall = Bodies.rectangle(400, 300, 20, 600, { isStatic: true });
        World.add(engine.world, [ground, leftWall, rightWall]);

        const fruits = [
            { label: "grape", color: "purple", size: 20, score: 10, next: "melon" },
            { label: "melon", color: "green", size: 40, score: 20, next: "watermelon" },
            { label: "watermelon", color: "red", size: 60, score: 30, next: null }
        ];

        let currentFruit = fruits[0];
        let fallingFruit = null;
        let isHolding = true;
        let score = 0;

        const updateScore = () => {
            document.getElementById("scoreValue").textContent = score;
        };

        const createFruit = (x, y, fruit) => {
            return Bodies.circle(x, y, fruit.size, {
                label: fruit.label,
                render: {
                    fillStyle: fruit.color
                }
            });
        };

        const mergeFruits = (fruitA, fruitB) => {
            const nextFruitType = fruits.find(f => f.label === fruitA.label).next;
            if (nextFruitType) {
                const nextFruit = fruits.find(f => f.label === nextFruitType);
                const newFruit = createFruit(
                    (fruitA.position.x + fruitB.position.x) / 2,
                    (fruitA.position.y + fruitB.position.y) / 2,
                    nextFruit
                );
                World.add(engine.world, newFruit);
                score += nextFruit.score;
                updateScore();
            } else {
                score += 50; // スイカ同士が消えた場合のボーナス
                updateScore();
            }
            World.remove(engine.world, [fruitA, fruitB]);
        };

        Events.on(engine, "collisionStart", event => {
            event.pairs.forEach(pair => {
                const labels = [pair.bodyA.label, pair.bodyB.label];
                if (labels[0] === labels[1]) {
                    mergeFruits(pair.bodyA, pair.bodyB);
                }
            });
        });

        const checkGameOver = () => {
            const bodies = Matter.Composite.allBodies(engine.world);
            for (const body of bodies) {
                if (body.position.y < 0 && body.isStatic === false) {
                    document.getElementById("gameOver").style.display = "block";
                    Render.stop(render);
                    Engine.clear(engine);
                    break;
                }
            }
        };

        const dropFruit = () => {
            isHolding = false;
            Body.setStatic(fallingFruit, false);
            setTimeout(() => {
                if (fallingFruit && !isHolding) {
                    fallingFruit = createFruit(200, 50, currentFruit);
                    World.add(engine.world, fallingFruit);
                    isHolding = true;
                }
            }, 1000);
        };

        document.addEventListener("keydown", event => {
            if (isHolding) {
                if (event.key === "ArrowLeft") {
                    Body.translate(fallingFruit, { x: -20, y: 0 });
                }
                if (event.key === "ArrowRight") {
                    Body.translate(fallingFruit, { x: 20, y: 0 });
                }
                if (event.key === " ") {
                    dropFruit();
                }
            }
        });

        fallingFruit = createFruit(200, 50, currentFruit);
        World.add(engine.world, fallingFruit);

        Render.run(render);
        Engine.run(engine);

        Events.on(engine, "afterUpdate", checkGameOver);
    </script>
</body>
</html>
